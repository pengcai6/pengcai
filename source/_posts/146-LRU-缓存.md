---
title: 146. LRU 缓存
tags:
  - 算法
  - LRU
categories:
  - java
  - 算法
keywords:
  - 算法
  - LRU
abbrlink: 45707
date: 2025-01-18 21:54:26
updated: 2025-01-18 21:54:26
---
# 146. LRU 缓存

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

## 解法1

```java
package leetcode.editor.cn.mycode.ID146;

import java.util.HashMap;


/**
 * 手写双向链表加哈希表
 */
public class LRUCache1 {
        class node{
            public int val,key;
            public node prev,next;

            public node(int key, int val) {
                this.key = key;
                this.val = val;
            }
        }
        class doubleList{
            public node tail;
            public node head;
            private int size;

            public doubleList() {
                this.size=0;
                head=new node(0,0);
                tail=new node(0,0);
                head.next=tail;
                tail.prev=head;
            }

            /**
             * 在尾部插入
             * @param x
             */
            public void addList(node x)
            {
                x.prev=tail.prev;
                x.next=tail;
                tail.prev.next=x;
                tail.prev=x;
                size++;
            }

            /**
             * 一定存在
             *
             * @param x
             */
            public void remove(node x){
            x.prev.next=x.next;
            x.next.prev=x.prev;
            size--;
            }

            public node removeFirst(){
                if(head.next==tail)
                {
                    return null;
                }
                node first = head.next;
                remove(first);
                return first;
            }

            public int size()
            {
                return size;
            }

        }



    HashMap<Integer,node> map;
    doubleList cache;

    int cap;
    public LRUCache1(int capacity) {
        this.cap=capacity;
        this.map =new HashMap<>();
        this.cache=new doubleList();
    }

    private void makeRecently(int key)
    {
        node node = map.get(key);
        cache.remove(node);
        cache.addList(node);
    }
    private void addRecently(int key ,int value)
    {
        node node = new node(key, value);
        cache.addList(node);
        map.put(key,node);
    }
    private void deleteKey(int key)
    {
        node node = map.get(key);
        cache.remove(node);
        map.remove(key);
    }

    private void removeLeastRecently(){
        node node = cache.removeFirst();
        map.remove(node.key);
    }


    public int get(int key) {
        if(!map.containsKey(key))
        {

            return -1;
        }
        makeRecently(key);
        return map.get(key).val;

    }

    public void put(int key, int value) {
        if(map.containsKey(key))
        {
            deleteKey(key);
            addRecently(key,value);
            return ;
        }
        if(cap==cache.size){
            removeLeastRecently();
        }
        addRecently(key,value);
    }


}

```

## 解法2

```java
package leetcode.editor.cn.mycode.ID146;

import java.util.LinkedHashMap;

/**
 * 使用java中自带的linkedHashMap
 */
public class LRUCache2 {
        int cap;
        LinkedHashMap<Integer,Integer> cache=new LinkedHashMap<>();


    public LRUCache2(int capacity) {
            this.cap=capacity;
    }

    public void makeRecently(int key)
    {
        Integer value = cache.get(key);
        //删除重新插入到队尾
        cache.remove(key);
        cache.put(key,value);
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        Integer value = cache.get(key);
        makeRecently(key);
    return value;
    }

    public void put(int key, int value) {
        if(cache.containsKey(key))
        {
            cache.put(key,value);
            makeRecently(key);
            return;
        }
        if(cache.size()>=cap)
        {
            //链表头部就是最久未使用的key
            Integer oldKey = cache.keySet().iterator().next();
            cache.remove(oldKey);
        }
        cache.put(key, value);
    }
}

```
